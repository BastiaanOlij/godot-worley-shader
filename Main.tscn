[gd_scene load_steps=8 format=2]

[ext_resource path="res://Main.gd" type="Script" id=1]
[ext_resource path="res://addons/shader_procedural_textures/Worley_texture.tscn" type="PackedScene" id=2]
[ext_resource path="res://Camera_Pivot.gd" type="Script" id=3]

[sub_resource type="CubeMesh" id=1]

size = Vector3( 2, 2, 2 )
subdivide_width = 0
subdivide_height = 0
subdivide_depth = 0

[sub_resource type="Shader" id=2]

code = "shader_type spatial;
render_mode unshaded, skip_vertex_transform;

uniform sampler2D albedo_texture : hint_albedo;
uniform float depth = 128.0;
uniform vec3 light_dir = vec3(0.0, 1.0, -1.0);
uniform float step_factor = 2.0;

varying vec3 pos;
varying vec3 dir;
varying vec3 ldir;
varying vec3 offset;

vec4 texture3d(sampler2D p_texture, vec3 p_uvw) {
	vec3 mod_uvw = mod(p_uvw + offset, 1.0);
	
	float fd = mod_uvw.z * depth;
	float fz = floor(fd);
	
	vec2 uv1 = vec2(mod_uvw.x, (mod_uvw.y + fz) / depth);
	vec2 uv2 = vec2(mod_uvw.x, mod((mod_uvw.y + fz + 1.0) / depth, 1.0));
	
	vec4 col1 = texture(p_texture, uv1);
	vec4 col2 = texture(p_texture, uv2);
	
	return mix(col1, col2, fd - fz);
}

void vertex() {
	// get our pos on the surface of our mesh in model space
	pos = VERTEX;
	
	// make our vertex position
	VERTEX = (MODELVIEW_MATRIX * vec4(VERTEX, 1.0)).xyz;
	
	// get our direction for our raymarch
	dir = (inverse(MODELVIEW_MATRIX) * vec4(normalize(VERTEX), 0.0)).xyz;
	
	// and our light dir
	ldir = (inverse(WORLD_MATRIX) * vec4(normalize(light_dir),0.0)).xyz;
	
	// wind..
	offset = vec3(TIME*0.2, 0.0, TIME*0.1);
}

float density(vec3 p_pos) {
	vec4 worley = texture3d(albedo_texture, p_pos);
	
	// join our octaves
	float value = worley.r + (0.5 * worley.g) + (0.25 * worley.b);
	
	// inverse and clamp
	value = clamp(1.0 - value, 0.0, 1.0);
	
	return value;
}

vec3 obsorb_light(vec3 p_pos) {
	vec3 color = vec3(0.0, 0.0, 0.0);
	
	vec3 p = p_pos;
	vec3 d = step_factor * ldir / 128.0;
	for(int i = 0; i < 128; i++) {
		float dens = density(p * 0.5) / 64.0;
		color += vec3(dens, dens, dens);
		
		// move towards the light...
		p = p + d;
		
		// still within our cube?
		if (p.x < -1.0 || p.x > 1.0 || p.y < -1.0 || p.y > 1.0 || p.z < -1.0 || p.z > 1.0) {
			break;
		}
	}
	
	return color;
}

void fragment() {
	vec3 color = vec3(1.0, 1.0, 1.0);
	float value = 0.0;
	
	// lets raymarch...
	vec3 p = pos;
	vec3 d = step_factor * dir / 128.0;
	for(int i = 0; i < 128; i++) {
		float dens = density(p * 0.5) / 32.0;
		
		color -= obsorb_light(p) * dens;
		value += dens;
		
		// reached the end?
		if (value > 1.0) {
			value = 1.0;
			break;
		}
		
		// move through our cube
		p = p + d;
		
		// still within our cube?
		if (p.x < -1.0 || p.x > 1.0 || p.y < -1.0 || p.y > 1.0 || p.z < -1.0 || p.z > 1.0) {
			break;
		}
	}
	
	ALBEDO = clamp(color, 0.0, 1.0);
	ALPHA = value;
}"
_sections_unfolded = [ "Resource" ]

[sub_resource type="ViewportTexture" id=3]

resource_local_to_scene = true
flags = 0
viewport_path = NodePath("Worley_texture")
_sections_unfolded = [ "Resource" ]

[sub_resource type="ShaderMaterial" id=4]

resource_local_to_scene = true
render_priority = 0
shader = SubResource( 2 )
shader_param/depth = 128.0
shader_param/light_dir = null
shader_param/step_factor = 2.0
shader_param/albedo_texture = SubResource( 3 )
_sections_unfolded = [ "Resource", "shader_param" ]

[node name="Main" type="Spatial" index="0"]

script = ExtResource( 1 )

[node name="Worley_texture" parent="." index="0" instance=ExtResource( 2 )]

texture_size = Vector3( 128, 128, 128 )

[node name="TestCube" type="MeshInstance" parent="." index="1"]

layers = 1
material_override = null
cast_shadow = 1
extra_cull_margin = 0.0
use_in_baked_light = false
lod_min_distance = 0.0
lod_min_hysteresis = 0.0
lod_max_distance = 0.0
lod_max_hysteresis = 0.0
mesh = SubResource( 1 )
skeleton = NodePath("..")
material/0 = SubResource( 4 )
_sections_unfolded = [ "Transform", "material" ]

[node name="DirectionalLight" type="DirectionalLight" parent="." index="2"]

transform = Transform( 0.634859, -0.71067, 0.303153, 0.641306, 0.703525, 0.306232, -0.430906, 0, 0.902397, 0, 3.09252, 0 )
layers = 1
light_color = Color( 1, 1, 1, 1 )
light_energy = 1.0
light_indirect_energy = 1.0
light_negative = false
light_specular = 0.5
light_bake_mode = 1
light_cull_mask = -1
shadow_enabled = false
shadow_color = Color( 0, 0, 0, 1 )
shadow_bias = 0.1
shadow_contact = 0.0
shadow_reverse_cull_face = false
editor_only = false
directional_shadow_mode = 2
directional_shadow_split_1 = 0.1
directional_shadow_split_2 = 0.2
directional_shadow_split_3 = 0.5
directional_shadow_blend_splits = false
directional_shadow_normal_bias = 0.8
directional_shadow_bias_split_scale = 0.25
directional_shadow_depth_range = 0
directional_shadow_max_distance = 200.0

[node name="HSlider" type="HSlider" parent="." index="3"]

anchor_left = 0.0
anchor_top = 0.0
anchor_right = 0.0
anchor_bottom = 0.0
margin_right = 551.0
margin_bottom = 16.0
rect_pivot_offset = Vector2( 0, 0 )
rect_clip_content = false
focus_mode = 2
mouse_filter = 0
mouse_default_cursor_shape = 0
size_flags_horizontal = 1
size_flags_vertical = 0
min_value = 1.0
max_value = 100.0
step = 1.0
page = 0.0
value = 1.0
exp_edit = false
rounded = false
editable = true
tick_count = 0
ticks_on_borders = false
focus_mode = 2

[node name="Camera Pivot" type="Position3D" parent="." index="4"]

script = ExtResource( 3 )

[node name="Camera" type="Camera" parent="Camera Pivot" index="0"]

transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 3 )
keep_aspect = 1
cull_mask = 1048575
environment = null
h_offset = 0.0
v_offset = 0.0
doppler_tracking = 0
projection = 0
current = false
fov = 70.0
size = 1.0
near = 0.05
far = 100.0
_sections_unfolded = [ "Transform" ]

[connection signal="value_changed" from="HSlider" to="." method="_on_HSlider_value_changed"]


