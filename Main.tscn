[gd_scene load_steps=10 format=2]

[ext_resource path="res://Main.gd" type="Script" id=1]
[ext_resource path="res://addons/shader_procedural_textures/Worley_texture.tscn" type="PackedScene" id=2]

[sub_resource type="CubeMesh" id=1]

size = Vector3( 2, 2, 2 )
subdivide_width = 0
subdivide_height = 0
subdivide_depth = 0

[sub_resource type="Shader" id=2]

code = "shader_type spatial;
render_mode unshaded, skip_vertex_transform;

uniform sampler2D albedo_texture : hint_albedo;
uniform float depth = 128.0;
uniform vec3 light_dir = vec3(1.0, 1.0, 1.0);

varying vec3 pos;
varying vec3 dir;
varying vec3 ldir;

vec4 texture3d(sampler2D p_texture, vec3 p_uvw) {
	vec3 mod_uvw = mod(p_uvw, 1.0);
	
	float fd = mod_uvw.z * depth;
	float fz = floor(fd);
	
	vec2 uv1 = vec2(mod_uvw.x, (mod_uvw.y + fz) / depth);
	vec2 uv2 = vec2(mod_uvw.x, mod((mod_uvw.y + fz + 1.0) / depth, 1.0));
	
	vec4 col1 = texture(p_texture, uv1);
	vec4 col2 = texture(p_texture, uv2);
	
	return mix(col1, col2, fd - fz);
}

void vertex() {
	// get our pos on the surface of our mesh in model space
	pos = VERTEX;
	
	// make our vertex position
	VERTEX = (MODELVIEW_MATRIX * vec4(VERTEX, 1.0)).xyz;
	
	// get our direction for our raymarch
	dir = (inverse(MODELVIEW_MATRIX) * vec4(normalize(VERTEX), 0.0)).xyz;
	
	// and our light dir
	ldir = normalize(light_dir);
}

float density(vec3 p_pos) {
	vec4 worley = texture3d(albedo_texture, p_pos);
	
	// join our octaves
	float value = worley.r + (0.5 * worley.g) + (0.25 * worley.b);
	
	// inverse and clamp
	value = clamp(1.0 - value, 0.0, 1.0);
	
	return value;
}

vec3 obsorb_light(vec3 p_pos) {
	vec3 color = vec3(0.0, 0.0, 0.0);
	
	vec3 p = p_pos;
	vec3 d = ldir / 16.0;
	for(int i = 0; i < 64; i++) {
		float dens = density(p * 0.5) * 0.001;
		color += vec3(dens, dens, dens);
		
		// move towards the light...
		p = p + d;
		
		// still within our cube?
		if (p.x < -1.0 || p.x > 1.0 || p.y < -1.0 || p.y > 1.0 || p.z < -1.0 || p.z > 1.0) {
			break;
		}
	}
	
	return color;
}

void fragment() {
	vec3 color = vec3(1.0, 1.0, 1.0);
	float value = 0.0;
	
	// lets raymarch...
	vec3 p = pos;
	vec3 d = dir / 32.0;
	for(int i = 0; i < 128; i++) {
		float dens = density(p * 0.5) / 64.0;
		
		color -= obsorb_light(p) * dens;
		value += dens;
		
		// reached the end?
		if (value > 1.0) {
			value = 1.0;
			break;
		}
		
		// move through our cube
		p = p + d;
		
		// still within our cube?
		if (p.x < -1.0 || p.x > 1.0 || p.y < -1.0 || p.y > 1.0 || p.z < -1.0 || p.z > 1.0) {
			break;
		}
	}
	
	ALBEDO = clamp(color, 0.0, 1.0);
	ALPHA = value;
}"

[sub_resource type="ViewportTexture" id=3]

resource_local_to_scene = true
flags = 0
viewport_path = NodePath("Worley_texture")
_sections_unfolded = [ "Resource" ]

[sub_resource type="ShaderMaterial" id=4]

resource_local_to_scene = true
render_priority = 0
shader = SubResource( 2 )
shader_param/depth = 128.0
shader_param/light_dir = null
shader_param/albedo_texture = SubResource( 3 )
_sections_unfolded = [ "Resource", "shader_param" ]

[sub_resource type="PlaneMesh" id=5]

size = Vector2( 2, 256 )
subdivide_width = 0
subdivide_depth = 0
_sections_unfolded = [ "Resource" ]

[sub_resource type="ViewportTexture" id=6]

resource_local_to_scene = true
flags = 0
viewport_path = NodePath("Worley_texture")

[sub_resource type="SpatialMaterial" id=7]

resource_local_to_scene = true
render_priority = 0
flags_transparent = false
flags_unshaded = false
flags_vertex_lighting = false
flags_no_depth_test = false
flags_use_point_size = false
flags_world_triplanar = false
flags_fixed_size = false
flags_albedo_tex_force_srgb = false
vertex_color_use_as_albedo = false
vertex_color_is_srgb = false
params_diffuse_mode = 0
params_specular_mode = 0
params_blend_mode = 0
params_cull_mode = 0
params_depth_draw_mode = 0
params_line_width = 1.0
params_point_size = 1.0
params_billboard_mode = 0
params_grow = false
params_use_alpha_scissor = false
albedo_color = Color( 1, 1, 1, 1 )
albedo_texture = SubResource( 6 )
metallic = 0.0
metallic_specular = 0.5
metallic_texture_channel = 0
roughness = 0.0
roughness_texture_channel = 0
emission_enabled = false
normal_enabled = false
rim_enabled = false
clearcoat_enabled = false
anisotropy_enabled = false
ao_enabled = false
depth_enabled = false
subsurf_scatter_enabled = false
transmission_enabled = false
refraction_enabled = false
detail_enabled = false
uv1_scale = Vector3( 1, 1, 1 )
uv1_offset = Vector3( 0, 0, 0 )
uv1_triplanar = false
uv1_triplanar_sharpness = 1.0
uv2_scale = Vector3( 1, 1, 1 )
uv2_offset = Vector3( 0, 0, 0 )
uv2_triplanar = false
uv2_triplanar_sharpness = 1.0
proximity_fade_enable = false
distance_fade_enable = false
_sections_unfolded = [ "Albedo", "Resource", "Vertex Color" ]

[node name="Main" type="Spatial" index="0"]

script = ExtResource( 1 )

[node name="Worley_texture" parent="." index="0" instance=ExtResource( 2 )]

texture_size = Vector3( 128, 128, 128 )

[node name="TestCube" type="MeshInstance" parent="." index="1"]

layers = 1
material_override = null
cast_shadow = 1
extra_cull_margin = 0.0
use_in_baked_light = false
lod_min_distance = 0.0
lod_min_hysteresis = 0.0
lod_max_distance = 0.0
lod_max_hysteresis = 0.0
mesh = SubResource( 1 )
skeleton = NodePath("..")
material/0 = SubResource( 4 )
_sections_unfolded = [ "Transform", "material" ]

[node name="TestTexture" type="MeshInstance" parent="." index="2"]

transform = Transform( 0.0503945, -0.15441, 0.986721, 0.950651, 0.310262, 0, -0.306142, 0.938027, 0.162426, 0, 0, -1.75436 )
visible = false
layers = 1
material_override = null
cast_shadow = 1
extra_cull_margin = 0.0
use_in_baked_light = false
lod_min_distance = 0.0
lod_min_hysteresis = 0.0
lod_max_distance = 0.0
lod_max_hysteresis = 0.0
mesh = SubResource( 5 )
skeleton = NodePath("..")
material/0 = SubResource( 7 )
_sections_unfolded = [ "material" ]

[node name="Camera" type="Camera" parent="." index="3"]

transform = Transform( 0.903796, -0.0584548, -0.423953, 0.317138, 0.756647, 0.571759, 0.287361, -0.651205, 0.702393, -0.94162, 1.7228, 2.1462 )
keep_aspect = 1
cull_mask = 1048575
environment = null
h_offset = 0.0
v_offset = 0.0
doppler_tracking = 0
projection = 0
current = false
fov = 70.0
size = 1.0
near = 0.05
far = 100.0

[node name="DirectionalLight" type="DirectionalLight" parent="." index="4"]

transform = Transform( 0.634859, -0.71067, 0.303153, 0.641306, 0.703525, 0.306232, -0.430906, 0, 0.902397, 0, 3.09252, 0 )
layers = 1
light_color = Color( 1, 1, 1, 1 )
light_energy = 1.0
light_indirect_energy = 1.0
light_negative = false
light_specular = 0.5
light_bake_mode = 1
light_cull_mask = -1
shadow_enabled = false
shadow_color = Color( 0, 0, 0, 1 )
shadow_bias = 0.1
shadow_contact = 0.0
shadow_reverse_cull_face = false
editor_only = false
directional_shadow_mode = 2
directional_shadow_split_1 = 0.1
directional_shadow_split_2 = 0.2
directional_shadow_split_3 = 0.5
directional_shadow_blend_splits = false
directional_shadow_normal_bias = 0.8
directional_shadow_bias_split_scale = 0.25
directional_shadow_depth_range = 0
directional_shadow_max_distance = 200.0

[node name="HSlider" type="HSlider" parent="." index="5"]

anchor_left = 0.0
anchor_top = 0.0
anchor_right = 0.0
anchor_bottom = 0.0
margin_right = 551.0
margin_bottom = 16.0
rect_pivot_offset = Vector2( 0, 0 )
rect_clip_content = false
focus_mode = 2
mouse_filter = 0
mouse_default_cursor_shape = 0
size_flags_horizontal = 1
size_flags_vertical = 0
min_value = 1.0
max_value = 100.0
step = 1.0
page = 0.0
value = 1.0
exp_edit = false
rounded = false
editable = true
tick_count = 0
ticks_on_borders = false
focus_mode = 2

[connection signal="value_changed" from="HSlider" to="." method="_on_HSlider_value_changed"]


